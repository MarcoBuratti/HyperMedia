<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Documentation</title>
</head>

<body>
    <h1 id="">Backend Documentation</h1>
    <blockquote>
        <p>Deliverable D1</p>
    </blockquote>
    <h3 id="group-info">General group information</h3>

    <figure>
        <table>
            <thead>
                <tr>
                    <th><span>Member n.</span></th>
                    <th><span>Role</span></th>
                    <th><span> First Name</span></th>
                    <th><span> Last Name</span></th>
                    <th><span> ID Number</span></th>
                    <th><span>Email address</span></th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><span>1</span></td>
                    <td><span>administrator</span></td>
                    <td><span> Marco</span></td>
                    <td><span> Buratti</span></td>
                    <td><span> 845766</span></td>
                    <td><span>marco1.buratti@mail.polimi.it</span></td>
                </tr>
                <tr>
                    <td><span>2</span></td>
                    <td><span>member</span></td>
                    <td><span> Christian</span></td>
                    <td><span> Cammareri</span></td>
                    <td><span> 920915</span></td>
                    <td><span>christian.cammareri@mail.polimi.it</span></td>
                </tr>
                <tr>
                    <td><span>3</span></td>
                    <td><span>member</span></td>
                    <td><span> Sergio</span></td>
                    <td><span> Canzoneri</span></td>
                    <td><span> 920187</span></td>
                    <td><span>sergio.canzoneri@mail.polimi.it</span></td>
                </tr>
            </tbody>
        </table>
    </figure>

    <h3 id="links">Links to other deliverables</h3>

    <blockquote>
        <p>Deliverable D0: The web application is reachable at this: <a
                href="https://buratticammarericanzoneri.herokuapp.com">address</a> </p>

        <p>Deliverable D2: The YAML file containing the specification of the appAPI can be found at this: <a
                href="https://buratticammarericanzoneri.herokuapp.com/backend/spec.yaml">address</a></p>

        <p>Deliverable D3: The SwaggerUI page of the same API is available at this: <a
                href="https://buratticammarericanzoneri.herokuapp.com/backend/swaggerui">address</a></p>

        <p>Deliverable D4: The source code of D0 is available as a zip file at this: <a
                href="https://buratticammarericanzoneri.herokuapp.com/backend/app.zip">address</a></p>

        <p>Deliverable D5: The address of the online source code repository is available at this: <a
                href="https://github.com/MarcoBuratti/HyperMedia">address</a>
            We hereby declare that this is a private repository and, upon request, we will give access to the
            instructors.</p>
    </blockquote>

    <h3 id="architecture">Web Architecture</h3>
    <ul>
        <img class="image" src="./img/architecture.png">
        <p>
            The Web server is based on an application generated by Swagger.io, we chose a Node.js server with a Connect
            module.
            <br>
            <br>
            The user (Presentation Layer) executes html requests to the server that responds with the contents of the
            Public folder. These files do not contain code that runs on the server side, so they are all considered user
            files. Folders contain only static files that are sent to the user's browser and are rendered locally. The
            dynamic parts of the html pages are delegated to JavaScript files.
            <br>
            <br>
            The RestAPIs (API Platform) are managed by the index.js file that takes care of keeping the server online
            and managing data traffic. Through DataLayer and Knex the server is able to forward requests to the database
            and respond to users.
            <br>
            <br>
            In the "Other" field, there are all the files related to the cookie session. Cookies are set by the server
            to the clients so that users can buy and browse the web page without having to enter their credentials each
            time.
        </p>
    </ul>

    <h2>API</h2>

    <h3 id="REST">REST compliance</h3>
    <ul>
        We have decided to follow these guidelines: the RESTs are drived by input parameters that a new request comes to
        server; we created an unique interface, the same for everyone.
    </ul>

    <h3 id="OpenAPI">OpenAPI Resource models</h3>
    <ul>
        <p>
            The following models have been used to represent the OpenAPI resources:
            <br>
            <li>Book: is composed by all informations about a book, as isbn, title, themes, genres, price and so;</li>
            <br>
            <li>Relation: is composed by two columns, isbn and id_author, and it links a book with its author/authors
                and
                viceversa;</li>
            <br>
            <li>Author: is composed by all informations about an author, as name and biography;</li>
            <br>
            <li>Event: is composed by all informations about an event, as name, isbn of the book presented and
                description;</li>
            <br>
            <li>User: is composed by all informations about an user, as name, mail and password;</li>
            <br>
            <li>Cart: is composed by all informations about the cart of a user, containing the book that it is going to
                buy.</li>
        </p>
    </ul>

    <h3 id="datamodel">Data model</h3>
    <ul>
        <img class="image" src="./img/dataModel.png">
        <p>The database consists of six tables, four of which are used to represent and manage the books, authors and
            events entities( Book, Relation, Author and Event), whereas the others two are dedicated to manage users'
            data (User and Cart).
            <br>
            <br>
            The main tables Author, Event and Book contain all the information to be shown on the front-end side in the
            relative single-pages. Event and Book are linked via through isbn pamameter, while the relationship between
            Authors and Books passes through the Relation table. This simple table consisting of only two columns (isbn,
            id_author) has the task of associating each book with its author/authors and viceversa (in the delivery
            documents it was indicated that a book could have up to four authors, but our solution works with N
            authors). Furthermore, regarding the cardinality of genres and themes, we assumed that it could be at most
            two (a similar solution for the authors with Relation would have extended the cardinality to N).
            <br>
            <br>
            The other two tables (User and Cart) deal with user management: in particular, the User table contains
            information (names, mails, passwords) about registered users, while Cart, with the id_user primary key, is
            made up of lines indicating the fact that the specific user has in his cart a specific book (isbn) with
            relative quantity and total cost. It should be emphasized that each user has N lines, where N indicates the
            number of books in the cart.
        </p>
    </ul>

    <h3 id="toolsused">Tools used</h3>
    <ul>
        We have used VisualStudio Code as an IDE to develop our site and we have generated a server by using
        swagger.io.
        The server is entirely written in JavaScript with the help of knex.js to generate the database and to fill
        it
        up. The server source code is generated from a nodejs-server application.
        As an interface to the DB we used pgAdmin4 and MySQL. The following JS tools have been used:
        body-parser": "^1.18.3", "connect": "^3.2.0","cookie-parser": "^1.4.4", "cookie-session": "^1.3.3",
        "js-yaml":
        "^3.3.0", "knex": "^0.14.6", "lodash": "^4.17.10", "pg": "^7.11.0", "process": "^0.11.10", "serve-static":
        "^1.14.0", "swagger-tools": "^0.10.4".
    </ul>

    <h3 id="discussion">Discussion</h3>
    <ul>
        <li>
            How did you make sure your web application adheres to the provided OpenAPI
            specification?
            <br>
            Having generated the code through Swagger Editor and having defined the REST API from the yaml file we then
            built the database on this generated code
            <br><br>
        </li>
        <li>Why do you think your web application adheres to common practices to partition the web application (static
            assets vs. application data)?<br>
            We have followed the guidelines of the slides shown in class to organize the paths of folders and files.
            The Server is organized in such a way as to have all the static documents in a single folder accessible from
            the HTML files. The dynamic components are all saved on the databases that can be accessed by QuerySQL.
            <br><br>
        </li>

        <li>Describe synthetically why and how did you manage session state, what are the
            state change triggering actions (e.g., POST to login etc..).
            <br>
            The functions that modify the database status are those related to the user. User/login, User/register,
            Cart/insert, Cart/cartdelete and Cart/bookDelete. The User functions allow us to register and log in,
            whereas
            the cart functions are used to fill the cart when adding books and to empty it when the purchase is made.
            <br><br>
        </li>

        <li>Which technology did you use (relational or a no-SQL database) for managing
            the data model?<br>
            We relied on knex.js to manage data and we implemented a relational database through the MySQL protocol. The
            database consists of six tables, four of which are used to represent and manage the books, authors and
            events
            entities, whereas the others two are dedicated to manage users' data.
            <br>
        </li>
    </ul>

    <h2 id="otherinformation">Other information</h2>

    <h3 id="taskassignment">Task assignment</h3>
    <ul>
        <li>Marco Buratti worked on front end (5% of the time) and OpenAPI Spec (45% of the time) and on the server code
            (50% of the time)</li>

        <li>Sergio Canzoneri worked on front end (90% of the time) and OpenAPI Spec (5% of the time) and on the server
            code
            (5% of the time)</li>

        <li>Christian Cammareri worked on front end (5% of the time) and OpenAPI Spec (45% of the time) and on the
            server
            code (50% of the time)</li>
    </ul>

    <h3 id="Analysis">Analysis of existing API</h3>
    <ul>
        To build the REST APIs we have tried to follow the guidelines seen during the course, taking as an example the
        pushed one on the git repository indicated to us, trying to maintain their clarity and simplicity.
        <br>
        We built paths using subresources, grouping them according to the reference table; they are modeled for specific
        delivery, returning useful data to the client to build a specific page.
        <br>
        There are some REST APIs that require a "form" as input: this "form" have to be built in the following way: 
        key1=value1&key2=value2&...
        <br>
        The REST APIs returns can be: 200 for successful operations, 400 or 404 for failed ones, and of course 500 if
        there
        are server side problems. The objects that all REST APIs return are of two type: for all GETs is always an array
        containing the requested data, while for POST/DELETE we return an object containing true/false, depending if the
        request is completed or not. implemented them paying attention to certain aspects, and considering the main
        issues with respect to the scope of the project.
    </ul>

    <h3 id="taskassignment">Learnig Outcome</h3>
    <ul>
        <li>
            Marco Buratti has worked for more than his time on server-side code and APIs. He learned to interface with a
            relational database, to manage a server-side connection and having worked on some html pages to a minimum,
            so he learned the basics of HTML and CSS.
            <br><br>
        </li>
        <li>
            Sergio Canzoneri has worked for more than his time on the client side, he has therefore developed remarkable
            skills in the use of HTML, CSS. Also having written most of the JavaScript of the html pages he learned to
            use JQuery. He also designed the tasks to be submitted to real users to perform the usability study.
            <br><br>
        </li>
        <li>
            Christian has spent much of his time thinking and building the useful REST APIs for delivery, writing the
            essential JavaScripit code for managing the requests on the server side, learning to manage them through
            knex.js. He also contributed in a small way also writing client-side code, again for the management of
            requests, also writing HTML code. He was particularly impressed by the client-server request management and
            plans to investigate further.
        </li>
    </ul>
</body>

</html>